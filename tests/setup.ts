/**\n * Test Setup and Utilities\n *\n * Provides common test utilities, fixtures, and setup/teardown functions\n * for unit, integration, and component tests.\n */\n\nimport { beforeAll, afterAll, beforeEach, afterEach, vi } from 'vitest';\nimport { logger } from '@server/_core/logger';\n\n/**\n * Global test setup\n * Runs once before all tests\n */\nbeforeAll(() => {\n  // Set test environment\n  process.env.NODE_ENV = 'test';\n  process.env.LOG_LEVEL = 'error';\n});\n\n/**\n * Global test teardown\n * Runs once after all tests\n */\nafterAll(() => {\n  // Cleanup\n});\n\n/**\n * Before each test\n * Runs before every test\n */\nbeforeEach(() => {\n  // Clear mocks\n  vi.clearAllMocks();\n});\n\n/**\n * After each test\n * Runs after every test\n */\nafterEach(() => {\n  // Cleanup\n});\n\n/**\n * Mock logger for testing\n * Prevents log output during tests\n */\nexport const mockLogger = {\n  error: vi.fn(),\n  warn: vi.fn(),\n  info: vi.fn(),\n  debug: vi.fn(),\n  trace: vi.fn(),\n  child: vi.fn(() => mockLogger),\n};\n\n/**\n * Create a test context with common utilities\n */\nexport function createTestContext() {\n  return {\n    logger: mockLogger,\n    now: Date.now(),\n  };\n}\n\n/**\n * Wait for a condition to be true\n * Useful for async operations in tests\n */\nexport async function waitFor(\n  condition: () => boolean,\n  options: { timeout?: number; interval?: number } = {}\n): Promise<void> {\n  const { timeout = 5000, interval = 100 } = options;\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeout) {\n    if (condition()) {\n      return;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n\n  throw new Error(`Condition not met within ${timeout}ms`);\n}\n\n/**\n * Create a mock request object\n */\nexport function createMockRequest(overrides = {}) {\n  return {\n    method: 'GET',\n    url: '/',\n    headers: {},\n    body: {},\n    params: {},\n    query: {},\n    ip: '127.0.0.1',\n    user: null,\n    ...overrides,\n  };\n}\n\n/**\n * Create a mock response object\n */\nexport function createMockResponse() {\n  const res: any = {\n    statusCode: 200,\n    headers: {},\n    status: vi.fn(function (code: number) {\n      this.statusCode = code;\n      return this;\n    }),\n    json: vi.fn(function (data: any) {\n      this.data = data;\n      return this;\n    }),\n    send: vi.fn(function (data: any) {\n      this.data = data;\n      return this;\n    }),\n    setHeader: vi.fn(function (key: string, value: string) {\n      this.headers[key] = value;\n      return this;\n    }),\n    getHeaders: vi.fn(function () {\n      return this.headers;\n    }),\n  };\n  return res;\n}\n\n/**\n * Create a mock next function\n */\nexport function createMockNext() {\n  return vi.fn();\n}\n\n/**\n * Assert that a function throws an error with a specific message\n */\nexport function expectErrorMessage(fn: () => void, message: string) {\n  try {\n    fn();\n    throw new Error('Expected function to throw');\n  } catch (error: any) {\n    if (!error.message.includes(message)) {\n      throw new Error(\n        `Expected error message to include \"${message}\", but got \"${error.message}\"`\n      );\n    }\n  }\n}\n
